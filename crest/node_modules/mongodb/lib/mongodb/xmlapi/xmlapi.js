/**
 * Experimental xmlapi for the mongodb node.js client.
 *
 * Based on https://github.com/henrikingo/xml2json
 *
 * We extend the mongodb client api with support for xml as an equal data format
 * with others. That makes the full list of supported data formats:
 *  - native js objects
 *  - json strings
 *  - xml strings
 *  - future: xml dom objects
 *  - bson objects? Is that really a thing in node.js? (It is in Java)
 *
 * The code that uses xml2json is in this file. There are hooks in collection.js
 * that calls this file.
 *
 * @depends on xml2json. This is supposed to be optional, but is currently hard wired into package.json
 *
 * PLEASE NOTE THAT THIS IS STILL INCOMPLETE AND EXPERIMENTAL!
 */

x = require('xml2json'); 
xml2json = x.xml2json; 
json2xml = x.json2xml;

module.exports = {
    /**
     * Instead of true, we return the dom object. In case you want it later, you don't have to parse everything twice.
     */
    isXmlString : function( s ){
        var dom = null;
        if( typeof s === 'string' && s.charAt(0) === '<' ) {
            try {
                dom = xml2json.parseXml(s);
            } catch (e) {
                return false;
            }
        }
        else {
            return false;
        }
        return dom;
    },
    xmlToObj : function( xmlStr ){
      var jsObj = xml2json.toObj( xml2json.parseXml( xmlStr ) );
      // If root element has an attribute "id", we will copy it to _id. Hence, it has to be globally unique in your db.
      var root = dom.documentElement;
      if ( dom.documentElement.getAttribute('id') ) {
        jsObj._id = dom.documentElement.getAttribute('id').toString();
      }
      return jsObj;        
    },
    domToObj : function( dom ){
      var jsObj = xml2json.toObj( dom );
      // If root element has an attribute "id", we will copy it to _id. Hence, it has to be globally unique in your db.
      var root = dom.documentElement;
      if ( dom.documentElement.getAttribute('id') ) {
        jsObj._id = dom.documentElement.getAttribute('id').toString();
      }
      return jsObj;        
    },
    // Xpath handling follows. I just hacked some regexes, for a real 
    // implementation there needs to be a proper parser that can return errors
    // for not supported syntax
    isXpathString : function( s ){
        if( typeof s === 'string' && s.charAt(0) === '/' ) {
            return true;
        }
        else {
            return false;
        }
    },
    objToXml : function( jsObj ) {
        // The MongoDB _id is not really part of the xml document, so we must delete it.
        // (If you defined an id attribute to the root object, that will be preserved)       
        delete jsObj["_id"];
        var xml = json2xml.toXml( jsObj );
        return xml;
    },
    // Translate /a/b/c into { "a.b.c" : { $exists : 1Â } } and /a/b[c=5] into { "a.b.c" : 5 }
    xpathToObj : function( xpathStr, defaultValue ) {
        if ( ! this.isXpathString( xpathStr ) ) {
            throw "not valid, or not supported, xpath string: " + xpathStr;
        }
        // optional argument
        if ( typeof defaultValue === 'undefined' ) {
            defaultValue = { "$exists" : 1 };
        }
        
        // Logic is roughly to translate xpathStr into { key : { filteroperator : value } }
        var obj = {}; // to be returned
        var key, value;
        var prefix, filter, postfix, filterkey, filteroperator, filtervalue;

        // Let's try to capture the square brackets in /a/b/c[@foo="baz"]
        var regex = /^(.*)\[(.*)\](.*)$/;
        var matches = [];
        if (matches = regex.exec(xpathStr)) {
            prefix = matches[1];
            filter = matches[2];
            postfix = matches[3]; //don't really know what to do if there's a postfix? completely ignoring it now.
            regex = /^(.*)(=|!=|<|<=|>|>=)(.*)$/;
            if ( matches = regex.exec(filter) ) {
                filterkey = matches[1];
                filteroperator = matches[2];
                filtervalue = matches[3];
            }
            if ( filterkey ) {
                if( filterkey.charAt(0) == "@" ) { //xml attribute
                    key = prefix + filterkey;
                }
                else {
                    key = prefix + "." + filterkey;
                }
            }
            else {
                key = prefix;
            }
        }
        else {
            key = xpathStr;
        }

        switch ( filteroperator ) {
            case "=":
                value = filtervalue;
                break;
            case "!=":
                value = { "$ne" : filtervalue };
                break;
            case "<":
                value = { "$lt" : filtervalue };
                break;
            case "<=":
                value = { "$lte" : filtervalue };
                break;
            case ">":
                value = { "$gt" : filtervalue };
                break;
            case ">=":
                value = { "$gte" : filtervalue };
                break;
            default:
                value = defaultValue;
        }
        

        // Last part is easy: Take /a/b/c/... and transform it to a.b.c. ...
        key = key.substring(1); // 1 to end
        key = key.replace( /\//g, "." );

        if ( key != '' ) {
            obj[key] = value;
        }
        else {
            obj = '';
        }
        return obj;
    }
}
