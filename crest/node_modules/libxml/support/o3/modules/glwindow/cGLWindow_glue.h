#ifdef O3_WITH_GLUE
#pragma warning( disable : 4100)
#pragma warning( disable : 4189)
namespace o3 {


Trait* cVector4::select()
{
   return clsTraits();
}

Trait* cVector4::clsTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cVector4",           0,                    0,              0,      cScr::clsTraits()  },
         {      0,      Trait::TYPE_END,        "cVector4",           0,                    0,              0,      0                  },
      };

      return TRAITS;
}

Trait* cVector4::extTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cVector4",           0,                    0,              0,      0                  },
         {      0,      Trait::TYPE_FUN,        "cO3",                "vec4",               extInvoke,      0,      0                  },
         {      0,      Trait::TYPE_END,        "cVector4",           0,                    0,              0,      0                  },
      };

      return TRAITS;
}

siEx cVector4::clsInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      return ex;
}

siEx cVector4::extInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cVector4* pthis1 = (cVector4*) pthis;

      switch(index) {
         case 0:
            if (argc != 4)
               return o3_new(cEx)("Invalid argument count. ( vec4 )");
            *rval = siVector4(pthis1->vec4(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble(),argv[3].toDouble()));
            break;
      }
      return ex;
}

}
#endif
#pragma warning(default : 4100)
#pragma warning(default : 4189)
#ifdef O3_WITH_GLUE
#pragma warning( disable : 4100)
#pragma warning( disable : 4189)
namespace o3 {


Trait* cVector3::select()
{
   return clsTraits();
}

Trait* cVector3::clsTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cVector3",           0,                    0,              0,      cScr::clsTraits()  },
         {      0,      Trait::TYPE_END,        "cVector3",           0,                    0,              0,      0                  },
      };

      return TRAITS;
}

Trait* cVector3::extTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cVector3",           0,                    0,              0,      0                  },
         {      0,      Trait::TYPE_FUN,        "cO3",                "vec3",               extInvoke,      0,      0                  },
         {      0,      Trait::TYPE_END,        "cVector3",           0,                    0,              0,      0                  },
      };

      return TRAITS;
}

siEx cVector3::clsInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      return ex;
}

siEx cVector3::extInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cVector3* pthis1 = (cVector3*) pthis;

      switch(index) {
         case 0:
            if (argc != 3)
               return o3_new(cEx)("Invalid argument count. ( vec3 )");
            *rval = siVector3(pthis1->vec3(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble()));
            break;
      }
      return ex;
}

}
#endif
#pragma warning(default : 4100)
#pragma warning(default : 4189)
#ifdef O3_WITH_GLUE
#pragma warning( disable : 4100)
#pragma warning( disable : 4189)
namespace o3 {


Trait* cVector2::select()
{
   return clsTraits();
}

Trait* cVector2::clsTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cVector2",           0,                    0,              0,      cScr::clsTraits()  },
         {      0,      Trait::TYPE_END,        "cVector2",           0,                    0,              0,      0                  },
      };

      return TRAITS;
}

Trait* cVector2::extTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cVector2",           0,                    0,              0,      0                  },
         {      0,      Trait::TYPE_FUN,        "cO3",                "vec2",               extInvoke,      0,      0                  },
         {      0,      Trait::TYPE_END,        "cVector2",           0,                    0,              0,      0                  },
      };

      return TRAITS;
}

siEx cVector2::clsInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      return ex;
}

siEx cVector2::extInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cVector2* pthis1 = (cVector2*) pthis;

      switch(index) {
         case 0:
            if (argc != 2)
               return o3_new(cEx)("Invalid argument count. ( vec2 )");
            *rval = siVector2(pthis1->vec2(argv[0].toDouble(),argv[1].toDouble()));
            break;
      }
      return ex;
}

}
#endif
#pragma warning(default : 4100)
#pragma warning(default : 4189)
#ifdef O3_WITH_GLUE
#pragma warning( disable : 4100)
#pragma warning( disable : 4189)
namespace o3 {


Trait* cMat44::select()
{
   return clsTraits();
}

Trait* cMat44::clsTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cMat44",             0,                    0,              0,      cScr::clsTraits()  },
         {      0,      Trait::TYPE_END,        "cMat44",             0,                    0,              0,      0                  },
      };

      return TRAITS;
}

Trait* cMat44::extTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cMat44",             0,                    0,              0,      0                  },
         {      0,      Trait::TYPE_FUN,        "cO3",                "mat44",              extInvoke,      0,      0                  },
         {      0,      Trait::TYPE_END,        "cMat44",             0,                    0,              0,      0                  },
      };

      return TRAITS;
}

siEx cMat44::clsInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      return ex;
}

siEx cMat44::extInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cMat44* pthis1 = (cMat44*) pthis;

      switch(index) {
         case 0:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( mat44 )");
            *rval = siMat44(pthis1->mat44());
            break;
      }
      return ex;
}

}
#endif
#pragma warning(default : 4100)
#pragma warning(default : 4189)
#ifdef O3_WITH_GLUE
#pragma warning( disable : 4100)
#pragma warning( disable : 4189)
namespace o3 {


Trait* cGLVertexArray::select()
{
   return clsTraits();
}

Trait* cGLVertexArray::clsTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cGLVertexArray",     0,                    0,              0,      cScr::clsTraits()  },
         {      0,      Trait::TYPE_FUN,        "cGLVertexArray",     "Render",             clsInvoke,      0,      0                  },
         {      1,      Trait::TYPE_FUN,        "cGLVertexArray",     "getSize",            clsInvoke,      1,      0                  },
         {      2,      Trait::TYPE_FUN,        "cGLVertexArray",     "setVertex",          clsInvoke,      2,      0                  },
         {      0,      Trait::TYPE_END,        "cGLVertexArray",     0,                    0,              0,      0                  },
      };

      return TRAITS;
}

Trait* cGLVertexArray::extTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cGLVertexArray",     0,                    0,              0,      0                  },
         {      0,      Trait::TYPE_FUN,        "cGLWindow",          "vertexarray",        extInvoke,      0,      0                  },
         {      1,      Trait::TYPE_FUN,        "cGLWindow",          "cube",               extInvoke,      1,      0                  },
         {      0,      Trait::TYPE_END,        "cGLVertexArray",     0,                    0,              0,      0                  },
      };

      return TRAITS;
}

siEx cGLVertexArray::clsInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cGLVertexArray* pthis1 = (cGLVertexArray*) pthis;

      switch(index) {
         case 0:
            if (argc > 3)
               return o3_new(cEx)("Invalid argument count. ( Render )");
            pthis1->Render(argc > 0 ? argv[0].toInt32() : GL_TRIANGLES,argc > 1 ? argv[1].toInt32() : 0,argc > 2 ? argv[2].toInt32() : 0xffffffff);
            break;
         case 1:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( getSize )");
            *rval = pthis1->getSize();
            break;
         case 2:
            if (argc != 9)
               return o3_new(cEx)("Invalid argument count. ( setVertex )");
            pthis1->setVertex(argv[0].toInt32(),argv[1].toDouble(),argv[2].toDouble(),argv[3].toDouble(),argv[4].toDouble(),argv[5].toDouble(),argv[6].toDouble(),argv[7].toDouble(),argv[8].toDouble());
            break;
      }
      return ex;
}

siEx cGLVertexArray::extInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cGLVertexArray* pthis1 = (cGLVertexArray*) pthis;

      switch(index) {
         case 0:
            if (argc != 1)
               return o3_new(cEx)("Invalid argument count. ( vertexarray )");
            *rval = siVertexArray(pthis1->vertexarray(argv[0].toInt32()));
            break;
         case 1:
            if (argc > 1)
               return o3_new(cEx)("Invalid argument count. ( cube )");
            *rval = siVertexArray(pthis1->cube(argc > 0 ? argv[0].toDouble() : 1.0));
            break;
      }
      return ex;
}

}
#endif
#pragma warning(default : 4100)
#pragma warning(default : 4189)
#ifdef O3_WITH_GLUE
#pragma warning( disable : 4100)
#pragma warning( disable : 4189)
namespace o3 {


Trait* cGLShaderProgram::select()
{
   return clsTraits();
}

Trait* cGLShaderProgram::clsTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cGLShaderProgram",   0,                    0,              0,      cScr::clsTraits()  },
         {      0,      Trait::TYPE_FUN,        "cGLShaderProgram",   "bind",               clsInvoke,      0,      0                  },
         {      1,      Trait::TYPE_FUN,        "cGLShaderProgram",   "unbind",             clsInvoke,      1,      0                  },
         {      0,      Trait::TYPE_END,        "cGLShaderProgram",   0,                    0,              0,      0                  },
      };

      return TRAITS;
}

Trait* cGLShaderProgram::extTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cGLShaderProgram",   0,                    0,              0,      0                  },
         {      0,      Trait::TYPE_FUN,        "cGLWindow",          "shaderprogram",      extInvoke,      0,      0                  },
         {      0,      Trait::TYPE_END,        "cGLShaderProgram",   0,                    0,              0,      0                  },
      };

      return TRAITS;
}

siEx cGLShaderProgram::clsInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cGLShaderProgram* pthis1 = (cGLShaderProgram*) pthis;

      switch(index) {
         case 0:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( bind )");
            pthis1->bind();
            break;
         case 1:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( unbind )");
            pthis1->unbind();
            break;
      }
      return ex;
}

siEx cGLShaderProgram::extInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cGLShaderProgram* pthis1 = (cGLShaderProgram*) pthis;

      switch(index) {
         case 0:
            if (argc != 2)
               return o3_new(cEx)("Invalid argument count. ( shaderprogram )");
            *rval = siShaderProgram(pthis1->shaderprogram(argv[0].toStr(),argv[1].toStr()));
            break;
      }
      return ex;
}

}
#endif
#pragma warning(default : 4100)
#pragma warning(default : 4189)
#ifdef O3_WITH_GLUE
#pragma warning( disable : 4100)
#pragma warning( disable : 4189)
namespace o3 {


Trait* cGLTexture::select()
{
   return clsTraits();
}

Trait* cGLTexture::clsTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cGLTexture",         0,                    0,              0,      cScr::clsTraits()  },
         {      0,      Trait::TYPE_FUN,        "cGLTexture",         "bind",               clsInvoke,      0,      0                  },
         {      1,      Trait::TYPE_FUN,        "cGLTexture",         "unbind",             clsInvoke,      1,      0                  },
         {      2,      Trait::TYPE_FUN,        "cGLTexture",         "upload",             clsInvoke,      2,      0                  },
         {      0,      Trait::TYPE_END,        "cGLTexture",         0,                    0,              0,      0                  },
      };

      return TRAITS;
}

Trait* cGLTexture::extTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cGLTexture",         0,                    0,              0,      0                  },
         {      0,      Trait::TYPE_FUN,        "cGLWindow",          "texture",            extInvoke,      0,      0                  },
         {      0,      Trait::TYPE_END,        "cGLTexture",         0,                    0,              0,      0                  },
      };

      return TRAITS;
}

siEx cGLTexture::clsInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cGLTexture* pthis1 = (cGLTexture*) pthis;

      switch(index) {
         case 0:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( bind )");
            pthis1->bind();
            break;
         case 1:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( unbind )");
            pthis1->unbind();
            break;
         case 2:
            if (argc < 1 && argc > 3)
               return o3_new(cEx)("Invalid argument count. ( upload )");
            pthis1->upload(argv[0].toScr(),argc > 1 ? argv[1].toInt32() : 0,argc > 2 ? argv[2].toInt32() : 0);
            break;
      }
      return ex;
}

siEx cGLTexture::extInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cGLTexture* pthis1 = (cGLTexture*) pthis;

      switch(index) {
         case 0:
            if (argc != 2)
               return o3_new(cEx)("Invalid argument count. ( texture )");
            *rval = siTexture(pthis1->texture(argv[0].toInt32(),argv[1].toInt32()));
            break;
      }
      return ex;
}

}
#endif
#pragma warning(default : 4100)
#pragma warning(default : 4189)
#ifdef O3_WITH_GLUE
#pragma warning( disable : 4100)
#pragma warning( disable : 4189)
namespace o3 {


Trait* cGLWindow::select()
{
   return clsTraits();
}

Trait* cGLWindow::clsTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cGLWindow",          0,                    0,              0,      cWindow::clsTraits()  },
         {      0,      Trait::TYPE_GET,        "cGLWindow",          "COLOR_BUFFER_BIT",   clsInvoke,      0,      0                  },
         {      1,      Trait::TYPE_GET,        "cGLWindow",          "DEPTH_BUFFER_BIT",   clsInvoke,      1,      0                  },
         {      2,      Trait::TYPE_GET,        "cGLWindow",          "TEXTURE_2D",         clsInvoke,      2,      0                  },
         {      3,      Trait::TYPE_GET,        "cGLWindow",          "BLEND",              clsInvoke,      3,      0                  },
         {      4,      Trait::TYPE_GET,        "cGLWindow",          "ALPHA_TEST",         clsInvoke,      4,      0                  },
         {      4,      Trait::TYPE_GET,        "cGLWindow",          "ALPHA_TEST",         clsInvoke,      5,      0                  },
         {      5,      Trait::TYPE_GET,        "cGLWindow",          "RGB",                clsInvoke,      6,      0                  },
         {      6,      Trait::TYPE_GET,        "cGLWindow",          "RGBA",               clsInvoke,      7,      0                  },
         {      7,      Trait::TYPE_GET,        "cGLWindow",          "MODELVIEW",          clsInvoke,      8,      0                  },
         {      8,      Trait::TYPE_GET,        "cGLWindow",          "PROJECTION",         clsInvoke,      9,      0                  },
         {      9,      Trait::TYPE_GET,        "cGLWindow",          "TEXTURE",            clsInvoke,      10,     0                  },
         {      10,     Trait::TYPE_GET,        "cGLWindow",          "POINTS",             clsInvoke,      11,     0                  },
         {      11,     Trait::TYPE_GET,        "cGLWindow",          "LINES",              clsInvoke,      12,     0                  },
         {      12,     Trait::TYPE_GET,        "cGLWindow",          "QUADS",              clsInvoke,      13,     0                  },
         {      13,     Trait::TYPE_GET,        "cGLWindow",          "QUAD_STRIP",         clsInvoke,      14,     0                  },
         {      14,     Trait::TYPE_GET,        "cGLWindow",          "TRIANGLES",          clsInvoke,      15,     0                  },
         {      15,     Trait::TYPE_GET,        "cGLWindow",          "TRIANGLE_STRIP",     clsInvoke,      16,     0                  },
         {      16,     Trait::TYPE_GET,        "cGLWindow",          "LIGHTING",           clsInvoke,      17,     0                  },
         {      17,     Trait::TYPE_GET,        "cGLWindow",          "LIGHT0",             clsInvoke,      18,     0                  },
         {      18,     Trait::TYPE_GET,        "cGLWindow",          "LIGHT1",             clsInvoke,      19,     0                  },
         {      19,     Trait::TYPE_GET,        "cGLWindow",          "LIGHT2",             clsInvoke,      20,     0                  },
         {      20,     Trait::TYPE_GET,        "cGLWindow",          "LIGHT3",             clsInvoke,      21,     0                  },
         {      21,     Trait::TYPE_GET,        "cGLWindow",          "LIGHT4",             clsInvoke,      22,     0                  },
         {      22,     Trait::TYPE_GET,        "cGLWindow",          "LIGHT5",             clsInvoke,      23,     0                  },
         {      23,     Trait::TYPE_GET,        "cGLWindow",          "LIGHT6",             clsInvoke,      24,     0                  },
         {      24,     Trait::TYPE_GET,        "cGLWindow",          "LIGHT7",             clsInvoke,      25,     0                  },
         {      25,     Trait::TYPE_GET,        "cGLWindow",          "AMBIENT",            clsInvoke,      26,     0                  },
         {      26,     Trait::TYPE_GET,        "cGLWindow",          "DIFFUSE",            clsInvoke,      27,     0                  },
         {      27,     Trait::TYPE_GET,        "cGLWindow",          "EMISSION",           clsInvoke,      28,     0                  },
         {      28,     Trait::TYPE_GET,        "cGLWindow",          "SHININESS",          clsInvoke,      29,     0                  },
         {      29,     Trait::TYPE_GET,        "cGLWindow",          "SPECULAR",           clsInvoke,      30,     0                  },
         {      30,     Trait::TYPE_GET,        "cGLWindow",          "POSITION",           clsInvoke,      31,     0                  },
         {      31,     Trait::TYPE_GET,        "cGLWindow",          "DEPTH_TEST",         clsInvoke,      32,     0                  },
         {      32,     Trait::TYPE_GET,        "cGLWindow",          "CULL_FACE",          clsInvoke,      33,     0                  },
         {      33,     Trait::TYPE_GET,        "cGLWindow",          "FRONT",              clsInvoke,      34,     0                  },
         {      34,     Trait::TYPE_GET,        "cGLWindow",          "BACK",               clsInvoke,      35,     0                  },
         {      35,     Trait::TYPE_GET,        "cGLWindow",          "FRONT_AND_BACK",     clsInvoke,      36,     0                  },
         {      36,     Trait::TYPE_GET,        "cGLWindow",          "CCW",                clsInvoke,      37,     0                  },
         {      37,     Trait::TYPE_GET,        "cGLWindow",          "CW",                 clsInvoke,      38,     0                  },
         {      38,     Trait::TYPE_GET,        "cGLWindow",          "NORMALIZE",          clsInvoke,      39,     0                  },
         {      39,     Trait::TYPE_FUN,        "cGLWindow",          "BeginFrame",         clsInvoke,      40,     0                  },
         {      40,     Trait::TYPE_FUN,        "cGLWindow",          "EndFrame",           clsInvoke,      41,     0                  },
         {      41,     Trait::TYPE_FUN,        "cGLWindow",          "invalidate",         clsInvoke,      42,     0                  },
         {      42,     Trait::TYPE_FUN,        "cGLWindow",          "SetUniform",         clsInvoke,      43,     0                  },
         {      43,     Trait::TYPE_FUN,        "cGLWindow",          "ClearColor",         clsInvoke,      44,     0                  },
         {      44,     Trait::TYPE_FUN,        "cGLWindow",          "Material",           clsInvoke,      45,     0                  },
         {      45,     Trait::TYPE_FUN,        "cGLWindow",          "Light",              clsInvoke,      46,     0                  },
         {      46,     Trait::TYPE_FUN,        "cGLWindow",          "Clear",              clsInvoke,      47,     0                  },
         {      47,     Trait::TYPE_FUN,        "cGLWindow",          "CullFace",           clsInvoke,      48,     0                  },
         {      48,     Trait::TYPE_FUN,        "cGLWindow",          "Enable",             clsInvoke,      49,     0                  },
         {      49,     Trait::TYPE_FUN,        "cGLWindow",          "Disable",            clsInvoke,      50,     0                  },
         {      50,     Trait::TYPE_FUN,        "cGLWindow",          "PushMatrix",         clsInvoke,      51,     0                  },
         {      51,     Trait::TYPE_FUN,        "cGLWindow",          "LoadIdentity",       clsInvoke,      52,     0                  },
         {      52,     Trait::TYPE_FUN,        "cGLWindow",          "PopMatrix",          clsInvoke,      53,     0                  },
         {      53,     Trait::TYPE_FUN,        "cGLWindow",          "Rotate",             clsInvoke,      54,     0                  },
         {      54,     Trait::TYPE_FUN,        "cGLWindow",          "PointSize",          clsInvoke,      55,     0                  },
         {      55,     Trait::TYPE_FUN,        "cGLWindow",          "LineWidth",          clsInvoke,      56,     0                  },
         {      56,     Trait::TYPE_FUN,        "cGLWindow",          "Vertex3",            clsInvoke,      57,     0                  },
         {      57,     Trait::TYPE_FUN,        "cGLWindow",          "TexCoord2",          clsInvoke,      58,     0                  },
         {      58,     Trait::TYPE_FUN,        "cGLWindow",          "Begin",              clsInvoke,      59,     0                  },
         {      59,     Trait::TYPE_FUN,        "cGLWindow",          "End",                clsInvoke,      60,     0                  },
         {      60,     Trait::TYPE_FUN,        "cGLWindow",          "Vertex2",            clsInvoke,      61,     0                  },
         {      61,     Trait::TYPE_FUN,        "cGLWindow",          "Color3",             clsInvoke,      62,     0                  },
         {      62,     Trait::TYPE_FUN,        "cGLWindow",          "Color4",             clsInvoke,      63,     0                  },
         {      63,     Trait::TYPE_FUN,        "cGLWindow",          "Scale",              clsInvoke,      64,     0                  },
         {      64,     Trait::TYPE_FUN,        "cGLWindow",          "Translate",          clsInvoke,      65,     0                  },
         {      65,     Trait::TYPE_FUN,        "cGLWindow",          "MatrixMode",         clsInvoke,      66,     0                  },
         {      66,     Trait::TYPE_FUN,        "cGLWindow",          "UseProgram",         clsInvoke,      67,     0                  },
         {      67,     Trait::TYPE_FUN,        "cGLWindow",          "Render",             clsInvoke,      68,     0                  },
         {      68,     Trait::TYPE_FUN,        "cGLWindow",          "Perspective",        clsInvoke,      69,     0                  },
         {      69,     Trait::TYPE_FUN,        "cGLWindow",          "Ortho2D",            clsInvoke,      70,     0                  },
         {      70,     Trait::TYPE_FUN,        "cGLWindow",          "LookAt",             clsInvoke,      71,     0                  },
         {      71,     Trait::TYPE_FUN,        "cGLWindow",          "Viewport",           clsInvoke,      72,     0                  },
         {      72,     Trait::TYPE_FUN,        "cGLWindow",          "Time",               clsInvoke,      73,     0                  },
         {      73,     Trait::TYPE_FUN,        "cGLWindow",          "ColorMask",          clsInvoke,      74,     0                  },
         {      0,      Trait::TYPE_END,        "cGLWindow",          0,                    0,              0,      0                  },
      };

      return TRAITS;
}

Trait* cGLWindow::extTraits()
{
      static Trait TRAITS[] = {
         {      0,      Trait::TYPE_BEGIN,      "cGLWindow",          0,                    0,              0,      0                  },
         {      0,      Trait::TYPE_FUN,        "cO3",                "createGLWindow",     extInvoke,      0,      0                  },
         {      0,      Trait::TYPE_END,        "cGLWindow",          0,                    0,              0,      0                  },
      };

      return TRAITS;
}

siEx cGLWindow::clsInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cGLWindow* pthis1 = (cGLWindow*) pthis;

      switch(index) {
         case 0:
            *rval = GL_COLOR_BUFFER_BIT;
            break;
         case 1:
            *rval = GL_DEPTH_BUFFER_BIT;
            break;
         case 2:
            *rval = GL_TEXTURE_2D;
            break;
         case 3:
            *rval = GL_BLEND;
            break;
         case 4:
            *rval = GL_ALPHA_TEST;
            break;
         case 5:
            *rval = GL_ALPHA_TEST;
            break;
         case 6:
            *rval = GL_RGB;
            break;
         case 7:
            *rval = GL_RGBA;
            break;
         case 8:
            *rval = GL_MODELVIEW;
            break;
         case 9:
            *rval = GL_PROJECTION;
            break;
         case 10:
            *rval = GL_TEXTURE;
            break;
         case 11:
            *rval = GL_POINTS;
            break;
         case 12:
            *rval = GL_LINES;
            break;
         case 13:
            *rval = GL_QUADS;
            break;
         case 14:
            *rval = GL_QUAD_STRIP;
            break;
         case 15:
            *rval = GL_TRIANGLES;
            break;
         case 16:
            *rval = GL_TRIANGLE_STRIP;
            break;
         case 17:
            *rval = GL_LIGHTING;
            break;
         case 18:
            *rval = GL_LIGHT0;
            break;
         case 19:
            *rval = GL_LIGHT1;
            break;
         case 20:
            *rval = GL_LIGHT2;
            break;
         case 21:
            *rval = GL_LIGHT3;
            break;
         case 22:
            *rval = GL_LIGHT4;
            break;
         case 23:
            *rval = GL_LIGHT5;
            break;
         case 24:
            *rval = GL_LIGHT6;
            break;
         case 25:
            *rval = GL_LIGHT7;
            break;
         case 26:
            *rval = GL_AMBIENT;
            break;
         case 27:
            *rval = GL_DIFFUSE;
            break;
         case 28:
            *rval = GL_EMISSION;
            break;
         case 29:
            *rval = GL_SHININESS;
            break;
         case 30:
            *rval = GL_SPECULAR;
            break;
         case 31:
            *rval = GL_POSITION;
            break;
         case 32:
            *rval = GL_DEPTH_TEST;
            break;
         case 33:
            *rval = GL_CULL_FACE;
            break;
         case 34:
            *rval = GL_FRONT;
            break;
         case 35:
            *rval = GL_BACK;
            break;
         case 36:
            *rval = GL_FRONT_AND_BACK;
            break;
         case 37:
            *rval = GL_CCW;
            break;
         case 38:
            *rval = GL_CW;
            break;
         case 39:
            *rval = GL_NORMALIZE;
            break;
         case 40:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( BeginFrame )");
            pthis1->BeginFrame();
            break;
         case 41:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( EndFrame )");
            pthis1->EndFrame();
            break;
         case 42:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( invalidate )");
            pthis1->invalidate();
            break;
         case 43:
            if (argc < 3 && argc > 4)
               return o3_new(cEx)("Invalid argument count. ( SetUniform )");
            pthis1->SetUniform(argv[0].toScr(),argv[1].toStr(),argv[2],argc > 3 ? argv[3].toInt32() : -1);
            break;
         case 44:
            if (argc != 4)
               return o3_new(cEx)("Invalid argument count. ( ClearColor )");
            pthis1->ClearColor(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble(),argv[3].toDouble());
            break;
         case 45:
            if (argc != 6)
               return o3_new(cEx)("Invalid argument count. ( Material )");
            pthis1->Material(argv[0].toInt32(),argv[1].toInt32(),argv[2].toDouble(),argv[3].toDouble(),argv[4].toDouble(),argv[5].toDouble());
            break;
         case 46:
            if (argc != 6)
               return o3_new(cEx)("Invalid argument count. ( Light )");
            pthis1->Light(argv[0].toInt32(),argv[1].toInt32(),argv[2].toDouble(),argv[3].toDouble(),argv[4].toDouble(),argv[5].toDouble());
            break;
         case 47:
            if (argc != 1)
               return o3_new(cEx)("Invalid argument count. ( Clear )");
            pthis1->Clear(argv[0].toInt32());
            break;
         case 48:
            if (argc != 1)
               return o3_new(cEx)("Invalid argument count. ( CullFace )");
            pthis1->CullFace(argv[0].toInt32());
            break;
         case 49:
            if (argc != 1)
               return o3_new(cEx)("Invalid argument count. ( Enable )");
            pthis1->Enable(argv[0].toInt32());
            break;
         case 50:
            if (argc != 1)
               return o3_new(cEx)("Invalid argument count. ( Disable )");
            pthis1->Disable(argv[0].toInt32());
            break;
         case 51:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( PushMatrix )");
            pthis1->PushMatrix();
            break;
         case 52:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( LoadIdentity )");
            pthis1->LoadIdentity();
            break;
         case 53:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( PopMatrix )");
            pthis1->PopMatrix();
            break;
         case 54:
            if (argc != 4)
               return o3_new(cEx)("Invalid argument count. ( Rotate )");
            pthis1->Rotate(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble(),argv[3].toDouble());
            break;
         case 55:
            if (argc != 1)
               return o3_new(cEx)("Invalid argument count. ( PointSize )");
            pthis1->PointSize(argv[0].toDouble());
            break;
         case 56:
            if (argc != 1)
               return o3_new(cEx)("Invalid argument count. ( LineWidth )");
            pthis1->LineWidth(argv[0].toDouble());
            break;
         case 57:
            if (argc != 3)
               return o3_new(cEx)("Invalid argument count. ( Vertex3 )");
            pthis1->Vertex3(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble());
            break;
         case 58:
            if (argc != 2)
               return o3_new(cEx)("Invalid argument count. ( TexCoord2 )");
            pthis1->TexCoord2(argv[0].toDouble(),argv[1].toDouble());
            break;
         case 59:
            if (argc != 1)
               return o3_new(cEx)("Invalid argument count. ( Begin )");
            pthis1->Begin(argv[0].toInt32());
            break;
         case 60:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( End )");
            pthis1->End();
            break;
         case 61:
            if (argc != 2)
               return o3_new(cEx)("Invalid argument count. ( Vertex2 )");
            pthis1->Vertex2(argv[0].toDouble(),argv[1].toDouble());
            break;
         case 62:
            if (argc != 3)
               return o3_new(cEx)("Invalid argument count. ( Color3 )");
            pthis1->Color3(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble());
            break;
         case 63:
            if (argc != 4)
               return o3_new(cEx)("Invalid argument count. ( Color4 )");
            pthis1->Color4(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble(),argv[3].toDouble());
            break;
         case 64:
            if (argc != 3)
               return o3_new(cEx)("Invalid argument count. ( Scale )");
            pthis1->Scale(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble());
            break;
         case 65:
            if (argc != 3)
               return o3_new(cEx)("Invalid argument count. ( Translate )");
            pthis1->Translate(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble());
            break;
         case 66:
            if (argc != 1)
               return o3_new(cEx)("Invalid argument count. ( MatrixMode )");
            pthis1->MatrixMode(argv[0].toInt32());
            break;
         case 67:
            if (argc != 1)
               return o3_new(cEx)("Invalid argument count. ( UseProgram )");
            pthis1->UseProgram(argv[0].toScr());
            break;
         case 68:
            if (argc < 1 && argc > 4)
               return o3_new(cEx)("Invalid argument count. ( Render )");
            pthis1->Render(argv[0].toScr(),argc > 1 ? argv[1].toInt32() : GL_TRIANGLES,argc > 2 ? argv[2].toInt32() : 0,argc > 3 ? argv[3].toInt32() : 0xffffffff);
            break;
         case 69:
            if (argc != 4)
               return o3_new(cEx)("Invalid argument count. ( Perspective )");
            pthis1->Perspective(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble(),argv[3].toDouble());
            break;
         case 70:
            if (argc != 4)
               return o3_new(cEx)("Invalid argument count. ( Ortho2D )");
            pthis1->Ortho2D(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble(),argv[3].toDouble());
            break;
         case 71:
            if (argc != 9)
               return o3_new(cEx)("Invalid argument count. ( LookAt )");
            pthis1->LookAt(argv[0].toDouble(),argv[1].toDouble(),argv[2].toDouble(),argv[3].toDouble(),argv[4].toDouble(),argv[5].toDouble(),argv[6].toDouble(),argv[7].toDouble(),argv[8].toDouble());
            break;
         case 72:
            if (argc != 4)
               return o3_new(cEx)("Invalid argument count. ( Viewport )");
            pthis1->Viewport(argv[0].toInt32(),argv[1].toInt32(),argv[2].toInt32(),argv[3].toInt32());
            break;
         case 73:
            if (argc != 0)
               return o3_new(cEx)("Invalid argument count. ( Time )");
            *rval = pthis1->Time();
            break;
         case 74:
            if (argc != 4)
               return o3_new(cEx)("Invalid argument count. ( ColorMask )");
            pthis1->ColorMask(argv[0].toBool(),argv[1].toBool(),argv[2].toBool(),argv[3].toBool());
            break;
      }
      return ex;
}

siEx cGLWindow::extInvoke(iScr* pthis, iCtx* ctx, int index, int argc,
           const Var* argv, Var* rval)
{
      siEx ex;
      cGLWindow* pthis1 = (cGLWindow*) pthis;

      switch(index) {
         case 0:
            if (argc != 5)
               return o3_new(cEx)("Invalid argument count. ( createGLWindow )");
            *rval = siWindow(pthis1->createGLWindow(pthis,argv[0].toStr(),argv[1].toInt32(),argv[2].toInt32(),argv[3].toInt32(),argv[4].toInt32()));
            break;
      }
      return ex;
}

}
#endif
#pragma warning(default : 4100)
#pragma warning(default : 4189)
